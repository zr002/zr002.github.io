<!DOCTYPE html>
<html>
<head>
  <title>SP 25 Apprentice Aiden Ren's Arcane Portal</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      text-align: center;
      background-color: #b2dfc9; 
    }
    h1 {
      color: #2f3243; 
    }
    h2 {
      color: #615F74; 
    }
    canvas {
      display: block;
      margin: 20px auto;
    }
  </style>
</head>
<body>
  <h1>Welcome to My Arcane Portal!</h1>
  <h2>Static Shape Rendering: Fishes with Tails and One Starfish</h2>
  <canvas id="webgpu-canvas" width="800" height="400"></canvas>

  <script type="module">
    async function initWebGPU() {
      const canvas = document.getElementById('webgpu-canvas');
      const context = canvas.getContext('webgpu');

      if (!navigator.gpu) {
        alert('WebGPU is not supported in this browser.');
        return;
      }

      const adapter = await navigator.gpu.requestAdapter();
      const device = await adapter.requestDevice();
      const canvasFormat = navigator.gpu.getPreferredCanvasFormat();

      context.configure({
        device: device,
        format: canvasFormat,
      });

      // Vertices for triangle fishes swimming left or right
      const triangleVertices = new Float32Array([
        // Fish 1 Body (Small, Swimming Right)
        -0.5, 0.5, 0.0,
        -0.6, 0.45, 0.0,
        -0.6, 0.55, 0.0,

        // Fish 2 Body (Medium, Swimming Left)
        0.3, -0.2, 0.0,
        0.5, -0.3, 0.0,
        0.5, -0.1, 0.0,

        // Fish 3 Body (Large, Swimming Right)
        -0.2, 0.0, 0.0,
        -0.5, -0.15, 0.0,
        -0.5, 0.15, 0.0,

        // Fish 4 Body (Small-Medium, Swimming Right)
        0.4, 0.3, 0.0,
        0.25, 0.25, 0.0,
        0.25, 0.35, 0.0,

        // Fish 5 Body (Tiny, Swimming Left)
        -0.6, -0.4, 0.0,
        -0.65, -0.42, 0.0,
        -0.65, -0.38, 0.0,

        // Fish 6 Body (Small, Swimming Right)
        -0.3, 0.7, 0.0,
        -0.4, 0.65, 0.0,
        -0.4, 0.75, 0.0,

        // Fish 7 Body (Large, Swimming Left)
        0.2, -0.6, 0.0,
        0.4, -0.7, 0.0,
        0.4, -0.5, 0.0,

        // Fish 8 Body (Medium, Swimming Right)
        -0.7, -0.1, 0.0,
        -0.9, -0.2, 0.0,
        -0.9, 0.0, 0.0,
      ]);

      // Vertices for triangle fish tails
      const tailVertices = new Float32Array([
        // Fish 1 Tail (Small, Swimming Right)
        -0.6, 0.5, 0.0,
        -0.65, 0.46, 0.0,
        -0.65, 0.54, 0.0,

        // Fish 2 Tail (Medium, Swimming Left)
        0.5, -0.2, 0.0,
        0.55, -0.25, 0.0,
        0.55, -0.15, 0.0,

        // Fish 3 Tail (Large, Swimming Right)
        -0.5, 0.0, 0.0,
        -0.55, -0.05, 0.0,
        -0.55, 0.05, 0.0,

        // Fish 4 Tail (Small-Medium, Swimming Right)
        0.25, 0.3, 0.0,
        0.2, 0.26, 0.0,
        0.2, 0.34, 0.0,

        // Fish 5 Tail (Tiny, Swimming Left)
        -0.65, -0.4, 0.0,
        -0.68, -0.43, 0.0,
        -0.68, -0.37, 0.0,

        // Fish 6 Tail (Small, Swimming Right)
        -0.4, 0.7, 0.0,
        -0.45, 0.66, 0.0,
        -0.45, 0.74, 0.0,

        // Fish 7 Tail (Large, Swimming Left)
        0.4, -0.6, 0.0,
        0.45, -0.65, 0.0,
        0.45, -0.55, 0.0,

        // Fish 8 Tail (Medium, Swimming Right)
        -0.9, -0.1, 0.0,
        -0.95, -0.15, 0.0,
        -0.95, -0.05, 0.0,
      ]);
      const starVertices = new Float32Array([
        // Upward-Pointing Triangle (equilateral, scaled, translated)
        0.7 + 0.0 * 0.7, -0.3 + 0.121, 0.0,    // Top vertex
        0.7 - 0.105, -0.3 - 0.06, 0.0,        // Bottom-left vertex
        0.7 + 0.105, -0.3 - 0.06, 0.0,        // Bottom-right vertex
      
        // Downward-Pointing Triangle (equilateral, scaled, translated)
        0.7 + 0.0 * 0.7, -0.3 - 0.221, 0.0,   // Bottom vertex
        0.7 - 0.105, -0.3 + 0.06, 0.0,        // Top-left vertex
        0.7 + 0.105, -0.3 + 0.06, 0.0,        // Top-right vertex
      ]);









      // Vertices for smaller dark blue rectangles (strips)
      const rectangleVertices = new Float32Array([
        // Rectangle 1
        -0.7, 0.8, 0.0,
        -0.7, 0.75, 0.0,
        -0.5, 0.75, 0.0,
        -0.7, 0.8, 0.0,
        -0.5, 0.75, 0.0,
        -0.5, 0.8, 0.0,

        // Rectangle 2
        0.1, 0.5, 0.0,
        0.1, 0.45, 0.0,
        0.3, 0.45, 0.0,
        0.1, 0.5, 0.0,
        0.3, 0.45, 0.0,
        0.3, 0.5, 0.0,

        // Rectangle 3
        -0.4, -0.5, 0.0,
        -0.4, -0.55, 0.0,
        -0.2, -0.55, 0.0,
        -0.4, -0.5, 0.0,
        -0.2, -0.55, 0.0,
        -0.2, -0.5, 0.0,

        // Rectangle 4
        -0.2, -0.2, 0.0,
        -0.2, -0.25, 0.0,
        0.0, -0.25, 0.0,
        -0.2, -0.2, 0.0,
        0.0, -0.25, 0.0,
        0.0, -0.2, 0.0,
      ]);

      // Create buffers for triangles, tails, rectangles, and stars
      const triangleBuffer = device.createBuffer({
        size: triangleVertices.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
      });
      device.queue.writeBuffer(triangleBuffer, 0, triangleVertices);

      const tailBuffer = device.createBuffer({
        size: tailVertices.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
      });
      device.queue.writeBuffer(tailBuffer, 0, tailVertices);

      const rectangleBuffer = device.createBuffer({
        size: rectangleVertices.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
      });
      device.queue.writeBuffer(rectangleBuffer, 0, rectangleVertices);

      const starBuffer = device.createBuffer({
        size: starVertices.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
      });
      device.queue.writeBuffer(starBuffer, 0, starVertices);

      // Shader for yellow triangles (fishes and tails)
      const triangleShaderModule = device.createShaderModule({
        code: `
          @vertex
          fn vertexMain(@location(0) position: vec3f) -> @builtin(position) vec4f {
            return vec4f(position, 1.0);
          }

          @fragment
          fn fragmentMain() -> @location(0) vec4f {
            return vec4f(1.0, 1.0, 0.0, 1.0); // Yellow color for triangles
          }
        `,
      });

      // Shader for orange starfish
      const starShaderModule = device.createShaderModule({
        code: `
          @vertex
          fn vertexMain(@location(0) position: vec3f) -> @builtin(position) vec4f {
            return vec4f(position, 1.0);
          }

          @fragment
          fn fragmentMain() -> @location(0) vec4f {
            return vec4f(1.0, 0.5, 0.0, 1.0); // Orange color for stars
          }
        `,
      });

      // Shader for dark blue rectangles (strips)
      const rectangleShaderModule = device.createShaderModule({
        code: `
          @vertex
          fn vertexMain(@location(0) position: vec3f) -> @builtin(position) vec4f {
            return vec4f(position, 1.0);
          }

          @fragment
          fn fragmentMain() -> @location(0) vec4f {
            return vec4f(0.0, 0.0, 0.5, 1.0); // Dark blue color for rectangles
          }
        `,
      });

      // Pipelines for triangles, rectangles, and stars
      const trianglePipeline = device.createRenderPipeline({
        layout: 'auto',
        vertex: {
          module: triangleShaderModule,
          entryPoint: 'vertexMain',
          buffers: [{
            arrayStride: 3 * Float32Array.BYTES_PER_ELEMENT,
            attributes: [{
              shaderLocation: 0,
              offset: 0,
              format: 'float32x3',
            }],
          }],
        },
        fragment: {
          module: triangleShaderModule,
          entryPoint: 'fragmentMain',
          targets: [{
            format: canvasFormat,
          }],
        },
        primitive: {
          topology: 'triangle-list',
        },
      });

      const rectanglePipeline = device.createRenderPipeline({
        layout: 'auto',
        vertex: {
          module: rectangleShaderModule,
          entryPoint: 'vertexMain',
          buffers: [{
            arrayStride: 3 * Float32Array.BYTES_PER_ELEMENT,
            attributes: [{
              shaderLocation: 0,
              offset: 0,
              format: 'float32x3',
            }],
          }],
        },
        fragment: {
          module: rectangleShaderModule,
          entryPoint: 'fragmentMain',
          targets: [{
            format: canvasFormat,
          }],
        },
        primitive: {
          topology: 'triangle-list',
        },
      });

      const starPipeline = device.createRenderPipeline({
        layout: 'auto',
        vertex: {
          module: starShaderModule,
          entryPoint: 'vertexMain',
          buffers: [{
            arrayStride: 3 * Float32Array.BYTES_PER_ELEMENT,
            attributes: [{
              shaderLocation: 0,
              offset: 0,
              format: 'float32x3',
            }],
          }],
        },
        fragment: {
          module: starShaderModule,
          entryPoint: 'fragmentMain',
          targets: [{
            format: canvasFormat,
          }],
        },
        primitive: {
          topology: 'triangle-strip',
        },
      });

      const commandEncoder = device.createCommandEncoder();

      const passEncoder = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: context.getCurrentTexture().createView(),
          clearValue: { r: 0.51, g: 0.83, b: 0.98, a: 1 }, // Light blue background
          loadOp: 'clear',
          storeOp: 'store',
        }],
      });

      // Draw triangle fishes
      passEncoder.setPipeline(trianglePipeline);
      passEncoder.setVertexBuffer(0, triangleBuffer);
      passEncoder.draw(triangleVertices.length / 3);

      // Draw triangle tails
      passEncoder.setVertexBuffer(0, tailBuffer);
      passEncoder.draw(tailVertices.length / 3);

      // Draw dark blue rectangles
      passEncoder.setPipeline(rectanglePipeline);
      passEncoder.setVertexBuffer(0, rectangleBuffer);
      passEncoder.draw(rectangleVertices.length / 3);

      // Draw one orange starfish
      passEncoder.setPipeline(starPipeline);
      passEncoder.setVertexBuffer(0, starBuffer);
      passEncoder.draw(starVertices.length / 3);

      passEncoder.end();

      device.queue.submit([commandEncoder.finish()]);
    }

    initWebGPU();
  </script>
</body>
</html>
